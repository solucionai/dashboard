# -*- coding: utf-8 -*-
"""estrutura.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1SiAX_nByBZsXkuO4Ax5-vIOOPZL_vJDr

# Puxando os dados do Analytics
"""

# !pip install google-analytics-data
# !pip install dash dash-bootstrap-components plotly flask

from google.analytics.data_v1beta import BetaAnalyticsDataClient, RunReportRequest, DateRange, Dimension, Metric
import requests
from datetime import datetime, timedelta
from flask import Flask
import dash
from dash import dcc, html, Input, Output
import dash_bootstrap_components as dbc
import plotly.express as px
import pandas as pd
import warnings

# Suprimir todos os warnings
warnings.filterwarnings("ignore")

"""# Puxando os dados da API do Pipedrive

"""

# Defina o seu API Token do Pipedrive
API_TOKEN = 'bbdd39fba4dab68ac0c03f4a629680f7429478ff'
BASE_URL = 'https://api.pipedrive.com/v1/'

# Função para extrair todos os dados de negócios utilizando paginação
def fetch_all_pipedrive_deals():
    all_deals = []
    start = 0
    limit = 100  # Número de registros por página

    while True:
        url = f'{BASE_URL}deals?start={start}&limit={limit}&api_token={API_TOKEN}'
        response = requests.get(url)

        if response.status_code == 200:
            deals = response.json().get('data', [])
            if not deals:
                break  # Encerra o loop se não houver mais dados

            all_deals.extend(deals)  # Adiciona os registros atuais à lista geral
            start += limit  # Atualiza o offset para a próxima página
        else:
            print(f"Erro ao extrair dados do Pipedrive: {response.status_code}")
            break

    # Converte todos os negócios extraídos em um DataFrame
    df_all_deals = pd.DataFrame(all_deals)
    print(f"Negócios do Pipedrive extraídos com sucesso. Total de registros: {len(df_all_deals)}")
    return df_all_deals

# Extraindo todos os dados de negócios
df_pipedrive = fetch_all_pipedrive_deals()

"""# Puxando as etiquetas"""

# Carregar o arquivo etiquetas.xlsx
df_etiquetas = pd.read_excel('etiquetas.xlsx')

# Substituir valores nulos por 0
df_etiquetas = df_etiquetas.fillna(0)

# Salvar como CSV
df_etiquetas.to_csv('etiquetas.csv', index=False)
print("Arquivo etiquetas.xlsx convertido para etiquetas.csv com sucesso e valores nulos substituídos por 0.")

# Carregar o arquivo etiquetas.xlsx
df_etiquetas = pd.read_excel('etiquetas.xlsx')

# Separar a coluna "Data Inscrição" para evitar alterações
coluna_data = df_etiquetas['Data Inscrição']

# Aplicar as mudanças nas outras colunas, exceto "Data Inscrição"
df_etiquetas = df_etiquetas.drop(columns=['Data Inscrição'])  # Remover temporariamente "Data Inscrição"
df_etiquetas = df_etiquetas.apply(pd.to_numeric, errors='coerce').fillna(0)  # Substituir nulos e valores não numéricos por 0
df_etiquetas = df_etiquetas.astype(int)  # Converter colunas numéricas de float para int

# Renomear a coluna 'Telefone' para 'numero_wpp'
df_etiquetas = df_etiquetas.rename(columns={'Telefone': 'numero_wpp'})

# Adicionar um '+' antes de todos os valores na coluna 'numero_wpp'
df_etiquetas['numero_wpp'] = df_etiquetas['numero_wpp'].apply(lambda x: f'+{x}')

# Recolocar a coluna "Data Inscrição" de volta ao DataFrame
df_etiquetas['Data Inscrição'] = coluna_data

df_hermes= pd.read_excel('hermes.xlsx')
df_gabi = pd.read_excel('gabi.xlsx')
df_contratog = pd.read_excel('contratog.xlsx')
df_contratoh = pd.read_excel('contratoh.xlsx')

"""# Puxando os dados do endpoint"""

# Função para buscar todos os dados do endpoint
def fetch_all_data(url):
    try:
        response = requests.get(url)
        if response.status_code == 200:
            data = response.json()
            return pd.DataFrame(data)  # Converte os dados em um DataFrame
        else:
            print(f"Error: {response.status_code}, Detail: {response.json().get('detail', 'No detail provided')}")
    except requests.RequestException as e:
        print(f"Failed to make the request: {e}")
        return pd.DataFrame()

# URL do endpoint
url = "https://web-production-c353.up.railway.app/retrieve_all"

# Chamando a função e obtendo os dados
df_endpoint = fetch_all_data(url)

# Verificação básica dos dados
if df_endpoint.empty:
    print("Os dados não foram carregados corretamente. Verifique o endpoint ou o formato dos dados.")
    exit()

# Função para calcular o tempo em cada etapa com base nas colunas de timestamp
def calculate_stage_duration(row):
    created_at = pd.to_datetime(row['created_at'], errors='coerce')
    last_modified = pd.to_datetime(row['last_modified'], errors='coerce')
    if pd.isnull(created_at) or pd.isnull(last_modified):
        return 0  # Retorna 0 se houver erro de conversão
    duration = (last_modified - created_at).total_seconds() / 60  # Duração em minutos
    return duration

# Função para extrair a última etapa (flag) alcançada na jornada
def extract_final_stage(raw_data):
    try:
        flags = {
            'voo': int(raw_data.get('FLAG_VOO_JORNADA', 0)),
            'negativacao': int(raw_data.get('FLAG_NEGATIVACAO_JORNADA', 0)),
            'telefonia': int(raw_data.get('FLAG_SERV_TELEF_JORNADA', 0)),
            'bancario': int(raw_data.get('FLAG_SERV_BANCARIO_JORNADA', 0)),
            'compra_online': int(raw_data.get('FLAG_COMPRA_ONLINE_JORNADA', 0)),
            'outros': int(raw_data.get('FLAG_OUTROS_JORNADA', 0)),
            'hospedagem': int(raw_data.get('FLAG_HOSPEDAGEM_JORNADA', 0))
        }
        final_stage = max(flags.values())  # Encontra a maior flag para determinar a etapa final
        return final_stage
    except Exception as e:
        print(f"Erro ao extrair etapa final: {e}")
        return 0

# Aplicar as funções ao dataframe
df_endpoint['created_at'] = pd.to_datetime(df_endpoint['created_at'], errors='coerce')
df_endpoint['Tempo_na_Etapa'] = df_endpoint.apply(calculate_stage_duration, axis=1)
df_endpoint['Etapa_Final'] = df_endpoint['RAW_DATA'].apply(extract_final_stage)
# Substituir valores NaN por 0 em todas as colunas do df_endpoint
df_endpoint = df_endpoint.fillna(0)

# Lista de colunas de interesse
columns = [
    'FLAG_HOSPEDAGEM_JORNADA',
    'FLAG_OUTROS_JORNADA',
    'FLAG_VOO_JORNADA',
    'FLAG_COMPRA_ONLINE_JORNADA',
    'FLAG_SERV_BANCARIO_JORNADA',
    'FLAG_NEGATIVACAO_JORNADA',
    'FLAG_SERV_TELEF_JORNADA'
]

# Converter as colunas para numérico, ignorando erros e preenchendo com NaN para valores não convertíveis
for col in columns:
    df_endpoint[col] = pd.to_numeric(df_endpoint[col], errors='coerce')

# Calcular o valor máximo para cada coluna
max_values = {col: df_endpoint[col].max() for col in columns}

# Determinar o valor máximo global entre todas as flags
max_global = max(max_values.values())

print("Valores máximos de cada coluna:")
for col, max_val in max_values.items():
    print(f"{col}: {max_val}")

print(f"Valor máximo global: {max_global}")

# Criar a coluna FLAG_FINAL, onde 1 indica que a pessoa chegou ao fim e 0 indica que não
df_endpoint['FLAG_FINAL'] = df_endpoint[columns].max(axis=1).apply(lambda x: 1 if x == max_global else 0)

# Exibir as primeiras linhas para ver o resultado
print(df_endpoint[['FLAG_FINAL'] + columns].head())

"""# Unificação e tratamento de dados"""

# Duplicar os DataFrames
df_endpoint_dup = df_endpoint
df_pipedrive_dup = df_pipedrive
df_etiquetas_dup = df_etiquetas
df_tudao2 = df_etiquetas.copy()

# # Mostrar as colunas do df_tudao
# print("Colunas presentes no df_tudao:")
# print(df_tudao.columns)

# # Calcular a porcentagem de valores nulos em cada coluna
# porcentagem_nulos = df_tudao.isnull().mean() * 100

# # Exibir a porcentagem de valores nulos por coluna
# print("\nPorcentagem de valores nulos em cada coluna:")
# print(porcentagem_nulos)

# Quebrar a coluna 'title' no df_pipedrive_dup em três colunas
df_pipedrive_dup[['id2', 'Problema2', 'numero_wpp']] = df_pipedrive_dup['title'].str.extract(r'(\d+)\s*-\s*(.*?)\s*-\s*(\+\d+)')

# Remover a coluna original 'title' depois de extrair os valores
df_pipedrive_dup.drop('title', axis=1, inplace=True)

# # Conferir se a operação foi realizada corretamente
# print(df_pipedrive_dup.head())

# Supondo que você já tenha df_endpoint_dup e df_pipedrive_dup

# Passo 1: Remover duplicatas no numero_wpp para evitar dados inconsistentes
df_endpoint_dup_clean = df_endpoint_dup.drop_duplicates(subset='numero_wpp')
df_pipedrive_dup_clean = df_pipedrive_dup.drop_duplicates(subset='numero_wpp')

# Passo 2: Realizar o merge com base no numero_wpp (inner join para manter apenas os números em comum)
df_merged = pd.merge(df_pipedrive_dup_clean, df_endpoint_dup_clean, on='numero_wpp', how='inner', suffixes=('_pipedrive', '_endpoint'))

# Passo 3: Reorganizar as colunas para que 'numero_wpp' seja a primeira
cols = ['numero_wpp'] + [col for col in df_merged.columns if col != 'numero_wpp']
df_merged = df_merged[cols]

# Passo 4: Igualar os valores da coluna 'deal_id' aos valores da coluna 'pipedrive_deal_id'
df_merged['deal_id'] = df_merged['pipedrive_deal_id']

# Exibir o dataframe resultante para verificar a mudança
# df_merged

# Supondo que já temos o df_merged e o df_etiquetas_dup carregados

# 1. Certificar-se de que a coluna 'numero_wpp' está formatada corretamente em ambos os dataframes
df_merged['numero_wpp'] = df_merged['numero_wpp'].astype(str)
df_etiquetas_dup['numero_wpp'] = df_etiquetas_dup['numero_wpp'].astype(str)

# 2. Realizar o merge com base na coluna 'numero_wpp', mantendo apenas os números que já existem no df_merged
df_final = pd.merge(df_merged, df_etiquetas_dup, on='numero_wpp', how='left')

# # 3. Exibir o resultado para verificar se a junção foi realizada corretamente
# df_final

# Também podemos verificar a quantidade de linhas para garantir que o merge foi feito corretamente:
print(f"Quantidade de pessoas no df_final: {df_final['numero_wpp'].nunique()}")

# Remover todas as linhas onde o valor na coluna 'POSSÍVEL' seja NaN
df_final_limpo = df_final.dropna(subset=['POSSÍVEL'])

# Exibir as primeiras linhas do DataFrame resultante para verificação
# df_final_limpo

# Certificar que estamos trabalhando com uma cópia do DataFrame para evitar o SettingWithCopyWarning
df_final_limpo = df_final_limpo.copy()

# Dicionário para mapear os DDDs aos estados
ddd_mapping_estados = {
    61: 'Distrito Federal',
    62: 'Goiás', 64: 'Goiás',
    65: 'Mato Grosso', 66: 'Mato Grosso',
    67: 'Mato Grosso do Sul',
    82: 'Alagoas',
    71: 'Bahia', 73: 'Bahia', 74: 'Bahia', 75: 'Bahia', 77: 'Bahia',
    85: 'Ceará', 88: 'Ceará',
    98: 'Maranhão', 99: 'Maranhão',
    83: 'Paraíba',
    81: 'Pernambuco', 87: 'Pernambuco',
    86: 'Piauí', 89: 'Piauí',
    84: 'Rio Grande do Norte',
    79: 'Sergipe',
    68: 'Acre',
    96: 'Amapá',
    92: 'Amazonas', 97: 'Amazonas',
    91: 'Pará', 93: 'Pará', 94: 'Pará',
    69: 'Rondônia',
    95: 'Roraima',
    63: 'Tocantins',
    27: 'Espírito Santo', 28: 'Espírito Santo',
    31: 'Minas Gerais', 32: 'Minas Gerais', 33: 'Minas Gerais', 34: 'Minas Gerais',
    35: 'Minas Gerais', 37: 'Minas Gerais', 38: 'Minas Gerais',
    21: 'Rio de Janeiro', 22: 'Rio de Janeiro', 24: 'Rio de Janeiro',
    11: 'São Paulo', 12: 'São Paulo', 13: 'São Paulo', 14: 'São Paulo',
    15: 'São Paulo', 16: 'São Paulo', 17: 'São Paulo', 18: 'São Paulo', 19: 'São Paulo',
    41: 'Paraná', 42: 'Paraná', 43: 'Paraná', 44: 'Paraná', 45: 'Paraná', 46: 'Paraná',
    51: 'Rio Grande do Sul', 53: 'Rio Grande do Sul', 54: 'Rio Grande do Sul', 55: 'Rio Grande do Sul',
    47: 'Santa Catarina', 48: 'Santa Catarina', 49: 'Santa Catarina'
}

# Função para garantir que o DDD é numérico e tratar erros
def tratar_ddd(ddd):
    try:
        return int(ddd)
    except ValueError:
        return None

# Tratando os valores de DDD
df_final_limpo['DDD'] = df_final_limpo['DDD'].apply(tratar_ddd)

# Aplicar o mapeamento de DDDs para Estados usando .loc para evitar SettingWithCopyWarning
df_final_limpo.loc[:, 'Estado'] = df_final_limpo['DDD'].map(ddd_mapping_estados)

# Exibindo os primeiros resultados para verificar se a mudança foi aplicada corretamente
print(df_final_limpo[['DDD', 'Estado']].head())

# Certificar que estamos trabalhando com uma cópia do DataFrame para evitar o SettingWithCopyWarning
df_final_limpo = df_final_limpo.copy()

# Dicionário para mapear os DDDs aos estados
ddd_mapping_estados = {
    61: 'Distrito Federal',
    62: 'Goiás', 64: 'Goiás',
    65: 'Mato Grosso', 66: 'Mato Grosso',
    67: 'Mato Grosso do Sul',
    82: 'Alagoas',
    71: 'Bahia', 73: 'Bahia', 74: 'Bahia', 75: 'Bahia', 77: 'Bahia',
    85: 'Ceará', 88: 'Ceará',
    98: 'Maranhão', 99: 'Maranhão',
    83: 'Paraíba',
    81: 'Pernambuco', 87: 'Pernambuco',
    86: 'Piauí', 89: 'Piauí',
    84: 'Rio Grande do Norte',
    79: 'Sergipe',
    68: 'Acre',
    96: 'Amapá',
    92: 'Amazonas', 97: 'Amazonas',
    91: 'Pará', 93: 'Pará', 94: 'Pará',
    69: 'Rondônia',
    95: 'Roraima',
    63: 'Tocantins',
    27: 'Espírito Santo', 28: 'Espírito Santo',
    31: 'Minas Gerais', 32: 'Minas Gerais', 33: 'Minas Gerais', 34: 'Minas Gerais',
    35: 'Minas Gerais', 37: 'Minas Gerais', 38: 'Minas Gerais',
    21: 'Rio de Janeiro', 22: 'Rio de Janeiro', 24: 'Rio de Janeiro',
    11: 'São Paulo', 12: 'São Paulo', 13: 'São Paulo', 14: 'São Paulo',
    15: 'São Paulo', 16: 'São Paulo', 17: 'São Paulo', 18: 'São Paulo', 19: 'São Paulo',
    41: 'Paraná', 42: 'Paraná', 43: 'Paraná', 44: 'Paraná', 45: 'Paraná', 46: 'Paraná',
    51: 'Rio Grande do Sul', 53: 'Rio Grande do Sul', 54: 'Rio Grande do Sul', 55: 'Rio Grande do Sul',
    47: 'Santa Catarina', 48: 'Santa Catarina', 49: 'Santa Catarina'
}

# Função para garantir que o DDD é numérico e tratar erros
def tratar_ddd(ddd):
    try:
        return int(ddd)
    except ValueError:
        return None

# Tratando os valores de DDD
df_tudao2['DDD'] = df_tudao2['DDD'].apply(tratar_ddd)

# Aplicar o mapeamento de DDDs para Estados usando .loc para evitar SettingWithCopyWarning
df_tudao2.loc[:, 'Estado'] = df_tudao2['DDD'].map(ddd_mapping_estados)

# Exibindo os primeiros resultados para verificar se a mudança foi aplicada corretamente
print(df_tudao2[['DDD', 'Estado']].head())

# # Criando o mapeamento correto para renomear os valores de 'stage_id' de números para strings
# stage_mapping = {
#     1: 'Captados',
#     8: 'Em Análise',
#     7: 'Recuperação'
# }

# # Aplicando o mapeamento corretamente usando .loc para evitar o SettingWithCopyWarning
# df_final_limpo.loc[:, 'stage_id'] = df_final_limpo['stage_id'].map(stage_mapping)

# # # Verifique se o mapeamento foi aplicado corretamente
# # print(df_final_limpo['stage_id'].unique())

# Identificar as colunas que possuem 100% de valores nulos
cols_to_drop = df_final_limpo.columns[df_final_limpo.isnull().sum() == len(df_final_limpo)]

# Dropar as colunas identificadas
df_final_limpo = df_final_limpo.drop(columns=cols_to_drop)

# Substituir todos os valores nulos por 0, exceto na coluna 'lost_reason'
df_final_limpo = df_final_limpo.apply(lambda col: col.fillna(0) if col.name != 'lost_reason' else col)

# import dash
# from dash import dcc, html
# import dash_bootstrap_components as dbc
# import plotly.express as px
# import pandas as pd
# from dash.dependencies import Input, Output

# # Utilizando a base de dados df_final_limpo, df_tudao, df_contratog e df_contratoh já carregadas
# df = df_final_limpo
# df_tudao = df_tudao2
# df_contratog = df_contratog
# df_contratoh = df_contratoh

# # Converter as colunas de data para o tipo datetime
# df['created_at'] = pd.to_datetime(df['created_at'], errors='coerce')
# df_tudao['Data Inscrição'] = pd.to_datetime(df_tudao['Data Inscrição'], errors='coerce')

# # Calcular a média de pessoas por dia
# total_pessoas = df_tudao['numero_wpp'].nunique()
# total_dias = df_tudao['Data Inscrição'].nunique()
# media_pessoas_dia = total_pessoas / total_dias if total_dias > 0 else 0

# # Inicializar o aplicativo Dash
# app = dash.Dash(__name__, external_stylesheets=[dbc.themes.BOOTSTRAP], suppress_callback_exceptions=True)

# # Estilos personalizados para os cards
# CARD_STYLE = {
#     "padding": "20px",
#     "border-radius": "5px",
#     "box-shadow": "2px 2px 10px rgba(0, 0, 0, 0.1)",
#     "text-align": "center",
#     "margin-left": "20px",
#     "background-color": "#007bff",  # Fundo azul para o card da média
#     "color": "white",  # Texto branco
#     "font-size": "24px",  # Texto maior
# }

# # Estilo personalizado para o card vermelho (Total de pessoas)
# CARD_STYLE_RED = {
#     "padding": "20px",
#     "border-radius": "5px",
#     "box-shadow": "2px 2px 10px rgba(0, 0, 0, 0.1)",
#     "text-align": "center",
#     "margin-left": "20px",
#     "background-color": "#ff4d4d",  # Fundo vermelho
#     "color": "white",  # Texto branco
#     "font-size": "24px",  # Texto maior
# }

# # Estilos personalizados
# SIDEBAR_STYLE = {
#     "position": "fixed",
#     "top": 0,
#     "left": 0,
#     "bottom": 0,
#     "width": "20%",
#     "padding": "20px",
#     "background-color": "#343a40",  # Cor da barra lateral (cinza escuro)
# }

# CONTENT_STYLE = {
#     "margin-left": "20%",
#     "padding": "20px",
#     "background-color": "#f8f9fa",  # Cor da parte central/direita (cinza claro)
#     "text-align": "center"  # Centralizar o texto
# }

# # Layout da barra lateral
# sidebar = html.Div(
#     [
#         html.H2("Dashboard", className="display-6", style={"color": "white"}),
#         html.Hr(),
#         html.P("Solucionaí", className="lead", style={"color": "white"}),
#         dbc.Nav(
#             [
#                 dbc.NavLink("Home", href="/home", id="home-button", style={"color": "white"}),
#                 dbc.NavLink("Leads", href="/leads", id="leads-button", style={"color": "white"}),
#                 dbc.NavLink("Atendentes", href="/atendentes", id="atendentes-button", style={"color": "white"}),
#             ],
#             vertical=True,
#             pills=True,
#         ),
#     ],
#     style=SIDEBAR_STYLE,
# )

# # Layout da parte central/direita
# content = html.Div(
#     [
#         html.H2("Dashboard de Dados Solucionaí", className="display-4"),
#         html.Hr(),
#         html.Div(id="page-content"),
#     ],
#     style=CONTENT_STYLE,
# )

# # Layout principal combinando a barra lateral e o conteúdo
# app.layout = html.Div([sidebar, content])

# # Callback para atualizar o conteúdo da página
# @app.callback(
#     Output("page-content", "children"),
#     [Input("home-button", "n_clicks"),
#      Input("leads-button", "n_clicks"),
#      Input("atendentes-button", "n_clicks")]
# )
# def display_page(n_home, n_leads, n_atendentes):
#     ctx = dash.callback_context  # Verificar qual botão foi clicado
#     filtered_df_tudao = df_tudao  # Filtrar df_tudao
#     filtered_df = df  # Filtrar df_final_limpo para os outros gráficos

#     if not ctx.triggered:
#         return html.H3("Home, seja bem-vindo ao Dashboard de Dados da Solucionaí!")
#     else:
#         button_id = ctx.triggered[0]['prop_id'].split('.')[0]
#         if button_id == "home-button":
#             return html.H3("Home, seja bem-vindo ao Dashboard de Dados da Solucionaí!")
#         elif button_id == "leads-button":
#             try:
#                 # Dropdown para selecionar o problema
#                 dropdown_problema = dcc.Dropdown(
#                     id='problema-dropdown',
#                     options=[{'label': problema, 'value': problema} for problema in filtered_df['PROBLEMA'].unique()],
#                     value=filtered_df['PROBLEMA'].unique()[0] if not filtered_df.empty else None,
#                     clearable=False,
#                     style={'width': '50%', 'margin-bottom': '20px'}
#                 )

#                 # Gráfico 1: Total de Leads Cadastrados na Base por Período de Tempo
#                 leads_by_date = df_tudao.groupby(df_tudao['Data Inscrição'].dt.date).size()
#                 fig_total_leads = px.line(x=leads_by_date.index, y=leads_by_date.values, title="Total de Leads por Período",
#                                           labels={'x': 'Data', 'y': 'Número de Leads'})

#                 # Adicionar números no gráfico para cada ponto
#                 fig_total_leads.add_scatter(x=leads_by_date.index, y=leads_by_date.values, mode='text',
#                                             text=leads_by_date.values, textposition="top center", showlegend=False)

#                 # Ajustando o range do eixo x para que não haja espaços no início e no final
#                 fig_total_leads.update_layout(
#                     xaxis=dict(range=[leads_by_date.index.min(), leads_by_date.index.max()])
#                 )

#                 # Card com a média de pessoas por dia (card azul)
#                 card_blue = html.Div([
#                     html.H4("Média de Pessoas por Dia", style={"margin-bottom": "10px"}),
#                     html.Div(f"{media_pessoas_dia:.2f}", style={"font-size": "36px", "font-weight": "bold"}),
#                 ], style=CARD_STYLE)

#                 # Card com o total de pessoas (card vermelho)
#                 card_red = html.Div([
#                     html.H4("Total de Pessoas na Base", style={"margin-bottom": "10px"}),
#                     html.Div(f"{total_pessoas}", style={"font-size": "36px", "font-weight": "bold"}),
#                 ], style=CARD_STYLE_RED)

#                 # Exibir informações de leads captados e proporção por problema selecionado
#                 leads_captados_total = len(df_tudao['numero_wpp'].unique())
#                 leads_captados_problema = len(filtered_df[filtered_df['PROBLEMA'] == dropdown_problema.value]['numero_wpp'].unique())
#                 proporcao_leads_problema = (leads_captados_problema / leads_captados_total * 100) if leads_captados_total > 0 else 0

#                 leads_info = html.Div([
#                     html.H4(f"Leads Captados no Problema Selecionado: {leads_captados_problema}"),
#                     html.H4(f"Proporção de Leads no Problema Selecionado: {proporcao_leads_problema:.2f}%")
#                 ], style={'text-align': 'left', 'margin': '20px 0'})

#                 # 2. Leads Cadastrados na Base por Tipo de Problema
#                 leads_by_problem = df['PROBLEMA'].value_counts()
#                 fig_leads_problema = px.bar(x=leads_by_problem.index, y=leads_by_problem.values, title="Leads por Tipo de Problema",
#                                             labels={'x': 'Tipo de Problema', 'y': 'Contagem de Leads'})

#                 # 3. Leads Cadastrados por Região ou DDD
#                 leads_by_ddd = df_tudao['Estado'].value_counts()
#                 leads_by_ddd = leads_by_ddd[leads_by_ddd > 9]  # Filtrar para exibir apenas os valores maiores que 9
#                 fig_leads_ddd = px.bar(x=leads_by_ddd.index, y=leads_by_ddd.values, title="Leads por Região",
#                                        labels={'x': 'Estado', 'y': 'Contagem de Leads'})

#                 # 4. Leads que Responderam o Fluxo até o Final
#                 completed_flow = df_tudao[df_tudao['COMPLETOU_O_FLUXO'] == 1].shape[0]
#                 fig_fluxo_completo = px.pie(values=[completed_flow, df_tudao.shape[0] - completed_flow],
#                                             names=['Completaram', 'Não Completaram'],
#                                             title="Leads que Completaram o Fluxo até o Final")

#                 # Gráfico: Contratos Fechados por Período
#                 contratos_by_date = df_tudao[df_tudao['CONTRATO ASSINADO'] == 1].groupby(df_tudao['Data Inscrição'].dt.date).size()
#                 fig_contratos_tempo = px.line(x=contratos_by_date.index, y=contratos_by_date.values, title="Contratos Fechados por Período",
#                                               labels={'x': 'Data', 'y': 'Número de Contratos Fechados'})

#                 # Gráfico: Leads que Não Prosseguiram após o Primeiro Contato
#                 leads_nao_prosseguiram = filtered_df[(filtered_df['ClienteDesistiu'] == 1) | (filtered_df['SEM RESPOSTA'] == 1)].shape[0]
#                 fig_leads_nao_prosseguiram = px.pie(values=[leads_nao_prosseguiram, filtered_df.shape[0] - leads_nao_prosseguiram],
#                                                     names=['Não Prosseguiram', 'Prosseguiram'],
#                                                     title="Leads que Não Prosseguiram após o Primeiro Contato")

#                 # Gráfico: Motivo de Perda dos Leads Não Elegíveis
#                 motivo_perda = filtered_df[filtered_df['NÃO ELEGÍVEL'] == 1]['lost_reason'].value_counts()
#                 fig_motivos_perda_leads = px.bar(x=motivo_perda.index, y=motivo_perda.values, title="Motivo de Perda dos Leads Não Elegíveis",
#                                                  labels={'x': 'Motivo', 'y': 'Número de Leads Não Elegíveis'})

#                 return html.Div([
#                     dropdown_problema,  # Dropdown para selecionar o problema
#                     html.Div([dcc.Graph(figure=fig_total_leads),
#                               html.Div([card_red, card_blue], style={"display": "flex", "flex-direction": "column", "align-items": "center", "gap": "20px"})],  # Os cards agora estão empilhados verticalmente
#                              style={'display': 'flex', 'align-items': 'flex-start'}),  # Gráfico 1 e Cards
#                     leads_info,  # Exibir leads captados
#                     dcc.Graph(figure=fig_leads_problema),  # Gráfico 2: Leads por Tipo de Problema
#                     dcc.Graph(figure=fig_leads_ddd),  # Gráfico 3: Leads por Região ou DDD
#                     dcc.Graph(figure=fig_fluxo_completo),  # Gráfico 4: Leads que completaram o fluxo
#                     dcc.Graph(figure=fig_contratos_tempo),  # Gráfico 5: Contratos fechados por tempo
#                     dcc.Graph(figure=fig_leads_nao_prosseguiram),  # Gráfico 6: Leads que Não Prosseguiram
#                     dcc.Graph(figure=fig_motivos_perda_leads)  # Gráfico 7: Motivo de Perda dos Leads Não Elegíveis
#                 ])
#             except Exception as e:
#                 return html.Div(f"Erro ao carregar os dados: {str(e)}")

#         elif button_id == "atendentes-button":
#             # Supondo que os DataFrames df_gabi, df_hermes, df_contratog, e df_contratoh já estejam carregados

#             # Gráfico 9: Atendimentos por Dia por Atendente
#             df_gabi['owner_name'] = 'Gabrielle'
#             df_hermes['owner_name'] = 'Hermes Moriguchi'
#             df_combined = pd.concat([df_gabi, df_hermes], ignore_index=True)
#             df_combined['Data Inscrição'] = pd.to_datetime(df_combined['Data Inscrição'], errors='coerce')
#             df_28 = df_combined[df_combined['Data Inscrição'] >= '2024-08-28']
#             atendimentos_por_dia = df_28.groupby([df_28['Data Inscrição'].dt.date, 'owner_name']).size().reset_index(name='Atendimentos')
#             fig_atendimentos_por_dia = px.line(atendimentos_por_dia, x='Data Inscrição', y='Atendimentos', color='owner_name',
#                                                title="Atendimentos por Dia por Atendente",
#                                                labels={'Data Inscrição': 'Data', 'Atendimentos': 'Número de Atendimentos'})

#             # Gráfico 11: Interações por Lead por Atendente
#             df_filtered_atendentes = filtered_df[filtered_df['owner_name'] != 'Solucionaí']
#             interacoes_por_lead = df_filtered_atendentes.groupby('owner_name').size()
#             fig_interacoes_por_lead = px.bar(x=interacoes_por_lead.index, y=interacoes_por_lead.values, title="Total de Interações com Leads por Atendente",
#                                              labels={'x': 'Atendente', 'y': 'Número de Leads'})

#             # Gráfico 12: Contratos Fechados por Gabrielle e Hermes (Total de valores na coluna "Telefone" de df_contratog e df_contratoh)
#             total_contratos_gabi = df_contratog['Telefone'].count()
#             total_contratos_hermes = df_contratoh['Telefone'].count()
#             fig_contratos_por_atendente = px.bar(x=['Gabrielle', 'Hermes Moriguchi'],
#                                                  y=[total_contratos_gabi, total_contratos_hermes],
#                                                  title="Contratos Fechados por Atendente",
#                                                  labels={'x': 'Atendente', 'y': 'Número de Contratos Fechados'})

#             return html.Div([
#                 dcc.Graph(figure=fig_atendimentos_por_dia),  # Gráfico 9: Atendimentos por Dia por Atendente
#                 dcc.Graph(figure=fig_interacoes_por_lead),  # Gráfico 11: Interações por Lead por Atendente
#                 dcc.Graph(figure=fig_contratos_por_atendente)  # Gráfico 12: Contratos Fechados por Gabrielle e Hermes
#             ])


# # Rodar o aplicativo
# if __name__ == "__main__":
#     app.run_server(debug=True)

# import dash
# from dash import dcc, html
# import dash_bootstrap_components as dbc
# import plotly.express as px
# import pandas as pd
# from dash.dependencies import Input, Output

# # Utilizando a base de dados df_final_limpo, df_tudao, df_contratog e df_contratoh já carregadas
# df = df_final_limpo
# df_tudao = df_tudao2
# df_contratog = df_contratog
# df_contratoh = df_contratoh

# # Converter as colunas de data para o tipo datetime
# df['created_at'] = pd.to_datetime(df['created_at'], errors='coerce')
# df_tudao['Data Inscrição'] = pd.to_datetime(df_tudao['Data Inscrição'], errors='coerce')

# # Calcular a média de pessoas por dia
# total_pessoas = df_tudao['numero_wpp'].nunique()
# total_dias = df_tudao['Data Inscrição'].nunique()
# media_pessoas_dia = total_pessoas / total_dias if total_dias > 0 else 0

# # Calcular total de contratos assinados
# total_contratos_assinados = df_tudao[df_tudao['CONTRATO ASSINADO'] == 1].shape[0]

# # Inicializar o aplicativo Dash
# app = dash.Dash(__name__, external_stylesheets=[dbc.themes.BOOTSTRAP], suppress_callback_exceptions=True)

# # Estilos personalizados para os cards
# CARD_STYLE = {
#     "padding": "20px",
#     "border-radius": "5px",
#     "box-shadow": "2px 2px 10px rgba(0, 0, 0, 0.1)",
#     "text-align": "center",
#     "margin-left": "20px",
#     "background-color": "#007bff",  # Fundo azul para o card da média
#     "color": "white",  # Texto branco
#     "font-size": "24px",  # Texto maior
# }

# # Estilo personalizado para o card vermelho (Total de pessoas)
# CARD_STYLE_RED = {
#     "padding": "20px",
#     "border-radius": "5px",
#     "box-shadow": "2px 2px 10px rgba(0, 0, 0, 0.1)",
#     "text-align": "center",
#     "margin-left": "20px",
#     "background-color": "#ff4d4d",  # Fundo vermelho
#     "color": "white",  # Texto branco
#     "font-size": "24px",  # Texto maior
# }

# # Estilo personalizado para o card verde (Total de contratos)
# CARD_STYLE_GREEN = {
#     "padding": "20px",
#     "border-radius": "5px",
#     "box-shadow": "2px 2px 10px rgba(0, 0, 0, 0.1)",
#     "text-align": "center",
#     "margin-left": "20px",
#     "background-color": "#28a745",  # Fundo verde
#     "color": "white",  # Texto branco
#     "font-size": "24px",  # Texto maior
# }

# # Estilos personalizados
# SIDEBAR_STYLE = {
#     "position": "fixed",
#     "top": 0,
#     "left": 0,
#     "bottom": 0,
#     "width": "20%",
#     "padding": "20px",
#     "background-color": "#343a40",  # Cor da barra lateral (cinza escuro)
# }

# CONTENT_STYLE = {
#     "margin-left": "20%",
#     "padding": "20px",
#     "background-color": "#f8f9fa",  # Cor da parte central/direita (cinza claro)
#     "text-align": "center"  # Centralizar o texto
# }

# # Layout da barra lateral
# sidebar = html.Div(
#     [
#         html.H2("Dashboard", className="display-6", style={"color": "white"}),
#         html.Hr(),
#         html.P("Solucionaí", className="lead", style={"color": "white"}),
#         dbc.Nav(
#             [
#                 dbc.NavLink("Home", href="/home", id="home-button", style={"color": "white"}),
#                 dbc.NavLink("Leads", href="/leads", id="leads-button", style={"color": "white"}),
#                 dbc.NavLink("Atendentes", href="/atendentes", id="atendentes-button", style={"color": "white"}),
#             ],
#             vertical=True,
#             pills=True,
#         ),
#     ],
#     style=SIDEBAR_STYLE,
# )

# # Layout da parte central/direita
# content = html.Div(
#     [
#         html.H2("Dashboard de Dados Solucionaí", className="display-4"),
#         html.Hr(),
#         html.Div(id="page-content"),
#     ],
#     style=CONTENT_STYLE,
# )

# # Layout principal combinando a barra lateral e o conteúdo
# app.layout = html.Div([sidebar, content])

# # Callback para atualizar o conteúdo da página
# @app.callback(
#     Output("page-content", "children"),
#     [Input("home-button", "n_clicks"),
#      Input("leads-button", "n_clicks"),
#      Input("atendentes-button", "n_clicks")]
# )
# def display_page(n_home, n_leads, n_atendentes):
#     ctx = dash.callback_context  # Verificar qual botão foi clicado
#     filtered_df_tudao = df_tudao  # Filtrar df_tudao
#     filtered_df = df  # Filtrar df_final_limpo para os outros gráficos

#     if not ctx.triggered:
#         return html.H3("Home, seja bem-vindo ao Dashboard de Dados da Solucionaí!")
#     else:
#         button_id = ctx.triggered[0]['prop_id'].split('.')[0]
#         if button_id == "home-button":
#             return html.H3("Home, seja bem-vindo ao Dashboard de Dados da Solucionaí!")
#         elif button_id == "leads-button":
#             try:
#                 # # Dropdown para selecionar o problema
#                 # dropdown_problema = dcc.Dropdown(
#                 #     id='problema-dropdown',
#                 #     options=[{'label': problema, 'value': problema} for problema in filtered_df['PROBLEMA'].unique()],
#                 #     value=filtered_df['PROBLEMA'].unique()[0] if not filtered_df.empty else None,
#                 #     clearable=False,
#                 #     style={'width': '50%', 'margin-bottom': '20px'}
#                 # )

#                 # Gráfico 1: Total de Leads Cadastrados na Base por Período de Tempo
#                 leads_by_date = df_tudao[df_tudao['Data Inscrição'] >= '2024-08-30'].groupby(df_tudao['Data Inscrição'].dt.date).size()
#                 fig_total_leads = px.line(x=leads_by_date.index, y=leads_by_date.values, title="Total de Leads por Período",
#                                           labels={'x': 'Data', 'y': 'Número de Leads'})


#                 # Adicionar números no gráfico para cada ponto
#                 fig_total_leads.add_scatter(x=leads_by_date.index, y=leads_by_date.values, mode='text',
#                                             text=leads_by_date.values, textposition="top center", showlegend=False)

#                 # Ajustando o range do eixo x para que não haja espaços no início e no final
#                 fig_total_leads.update_layout(
#                     xaxis=dict(range=[leads_by_date.index.min(), leads_by_date.index.max()])
#                 )

#                 # Card com a média de pessoas por dia (card azul)
#                 card_blue = html.Div([
#                     html.H4("Média de Pessoas por Dia", style={"margin-bottom": "10px"}),
#                     html.Div(f"{media_pessoas_dia:.2f}", style={"font-size": "36px", "font-weight": "bold"}),
#                 ], style=CARD_STYLE)

#                 # Card com o total de pessoas (card vermelho)
#                 card_red = html.Div([
#                     html.H4("Total de Pessoas na Base", style={"margin-bottom": "10px"}),
#                     html.Div(f"{total_pessoas}", style={"font-size": "36px", "font-weight": "bold"}),
#                 ], style=CARD_STYLE_RED)

#                 # Card com o total de contratos assinados (card verde)
#                 card_green = html.Div([
#                     html.H4("Total de Contratos Assinados", style={"margin-bottom": "10px"}),
#                     html.Div(f"{total_contratos_assinados}", style={"font-size": "36px", "font-weight": "bold"}),
#                 ], style=CARD_STYLE_GREEN)

#                 # Exibir informações de leads captados e proporção por problema selecionado
#                 leads_captados_total = len(df_tudao['numero_wpp'].unique())
#                 # leads_captados_problema = len(filtered_df[filtered_df['PROBLEMA'] == dropdown_problema.value]['numero_wpp'].unique())
#                 # proporcao_leads_problema = (leads_captados_problema / leads_captados_total * 100) if leads_captados_total > 0 else 0

#                 # leads_info = html.Div([
#                 #     html.H4(f"Leads Captados no Problema Selecionado: {leads_captados_problema}"),
#                 #     html.H4(f"Proporção de Leads no Problema Selecionado: {proporcao_leads_problema:.2f}%")
#                 # ], style={'text-align': 'left', 'margin': '20px 0'})

#                 # 2. Leads Cadastrados na Base por Tipo de Problema
#                 leads_by_problem = df['PROBLEMA'].value_counts()
#                 fig_leads_problema = px.bar(x=leads_by_problem.index, y=leads_by_problem.values, title="Leads por Tipo de Problema",
#                                             labels={'x': 'Tipo de Problema', 'y': 'Contagem de Leads'})

#                 # 3. Leads Cadastrados por Região ou DDD
#                 leads_by_ddd = df_tudao['Estado'].value_counts()
#                 leads_by_ddd = leads_by_ddd[leads_by_ddd > 9]  # Filtrar para exibir apenas os valores maiores que 9
#                 fig_leads_ddd = px.bar(x=leads_by_ddd.index, y=leads_by_ddd.values, title="Leads por Região",
#                                        labels={'x': 'Estado', 'y': 'Contagem de Leads'})

#                 # 4. Leads que Responderam o Fluxo até o Final
#                 completed_flow = df_tudao[df_tudao['COMPLETOU_O_FLUXO'] == 1].shape[0]
#                 fig_fluxo_completo = px.pie(values=[completed_flow, df_tudao.shape[0] - completed_flow],
#                                             names=['Completaram', 'Não Completaram'],
#                                             title="Leads que Completaram o Fluxo até o Final")

#                 # Gráfico: Contratos Fechados por Período
#                 contratos_by_date = df_tudao[df_tudao['CONTRATO ASSINADO'] == 1].groupby(df_tudao['Data Inscrição'].dt.date).size()
#                 fig_contratos_tempo = px.line(x=contratos_by_date.index, y=contratos_by_date.values, title="Contratos Fechados por Período",
#                                               labels={'x': 'Data', 'y': 'Número de Contratos Fechados'})

#                 # Gráfico: Leads que Não Prosseguiram após o Primeiro Contato
#                 leads_nao_prosseguiram = filtered_df[(filtered_df['ClienteDesistiu'] == 1) | (filtered_df['SEM RESPOSTA'] == 1)].shape[0]
#                 fig_leads_nao_prosseguiram = px.pie(values=[leads_nao_prosseguiram, filtered_df.shape[0] - leads_nao_prosseguiram],
#                                                     names=['Não Prosseguiram', 'Prosseguiram'],
#                                                     title="Leads que Não Prosseguiram após o Primeiro Contato")

#                 # Gráfico: Motivo de Perda dos Leads Não Elegíveis
#                 motivo_perda = filtered_df[filtered_df['NÃO ELEGÍVEL'] == 1]['lost_reason'].value_counts()
#                 fig_motivos_perda_leads = px.bar(x=motivo_perda.index, y=motivo_perda.values, title="Motivo de Perda dos Leads Não Elegíveis",
#                                                  labels={'x': 'Motivo', 'y': 'Número de Leads Não Elegíveis'})

#                 return html.Div([
#                     # dropdown_problema,  # Dropdown para selecionar o problema
#                     html.Div([dcc.Graph(figure=fig_total_leads),
#                               html.Div([card_red, card_blue, card_green], style={"display": "flex", "flex-direction": "column", "align-items": "center", "gap": "20px"})],  # Os cards agora estão empilhados verticalmente
#                              style={'display': 'flex', 'align-items': 'flex-start'}),  # Gráfico 1 e Cards
#                     # leads_info,  # Exibir leads captados
#                     dcc.Graph(figure=fig_leads_problema),  # Gráfico 2: Leads por Tipo de Problema
#                     dcc.Graph(figure=fig_leads_ddd),  # Gráfico 3: Leads por Região ou DDD
#                     dcc.Graph(figure=fig_fluxo_completo),  # Gráfico 4: Leads que completaram o fluxo
#                     dcc.Graph(figure=fig_contratos_tempo),  # Gráfico 5: Contratos fechados por tempo
#                     dcc.Graph(figure=fig_leads_nao_prosseguiram),  # Gráfico 6: Leads que Não Prosseguiram
#                     dcc.Graph(figure=fig_motivos_perda_leads)  # Gráfico 7: Motivo de Perda dos Leads Não Elegíveis
#                 ])
#             except Exception as e:
#                 return html.Div(f"Erro ao carregar os dados: {str(e)}")

#         elif button_id == "atendentes-button":
#             # Supondo que os DataFrames df_gabi, df_hermes, df_contratog, e df_contratoh já estejam carregados

#             # Gráfico 9: Atendimentos por Dia por Atendente
#             df_gabi['owner_name'] = 'Gabrielle'
#             df_hermes['owner_name'] = 'Hermes Moriguchi'
#             df_combined = pd.concat([df_gabi, df_hermes], ignore_index=True)
#             df_combined['Data Inscrição'] = pd.to_datetime(df_combined['Data Inscrição'], errors='coerce')
#             df_28 = df_combined[df_combined['Data Inscrição'] >= '2024-08-30']
#             atendimentos_por_dia = df_28.groupby([df_28['Data Inscrição'].dt.date, 'owner_name']).size().reset_index(name='Atendimentos')
#             fig_atendimentos_por_dia = px.line(atendimentos_por_dia, x='Data Inscrição', y='Atendimentos', color='owner_name',
#                                                title="Atendimentos por Dia por Atendente",
#                                                labels={'Data Inscrição': 'Data', 'Atendimentos': 'Número de Atendimentos'})

#             # Gráfico 11: Interações por Lead por Atendente
#             df_filtered_atendentes = filtered_df[filtered_df['owner_name'] != 'Solucionaí']
#             interacoes_por_lead = df_filtered_atendentes.groupby('owner_name').size()
#             fig_interacoes_por_lead = px.bar(x=interacoes_por_lead.index, y=interacoes_por_lead.values, title="Total de Interações com Leads por Atendente",
#                                              labels={'x': 'Atendente', 'y': 'Número de Leads'})

#             # Gráfico 12: Contratos Fechados por Gabrielle e Hermes (Total de valores na coluna "Telefone" de df_contratog e df_contratoh)
#             total_contratos_gabi = df_contratog['Telefone'].count()
#             total_contratos_hermes = df_contratoh['Telefone'].count()
#             fig_contratos_por_atendente = px.bar(x=['Gabrielle', 'Hermes Moriguchi'],
#                                                  y=[total_contratos_gabi, total_contratos_hermes],
#                                                  title="Contratos Fechados por Atendente",
#                                                  labels={'x': 'Atendente', 'y': 'Número de Contratos Fechados'})

#             return html.Div([
#                 dcc.Graph(figure=fig_atendimentos_por_dia),  # Gráfico 9: Atendimentos por Dia por Atendente
#                 dcc.Graph(figure=fig_interacoes_por_lead),  # Gráfico 11: Interações por Lead por Atendente
#                 dcc.Graph(figure=fig_contratos_por_atendente)  # Gráfico 12: Contratos Fechados por Gabrielle e Hermes
#             ])


# # Rodar o aplicativo
# if __name__ == "__main__":
#     app.run_server(debug=True)

# import dash
# from dash import dcc, html
# import dash_bootstrap_components as dbc
# import plotly.express as px
# import pandas as pd
# from dash.dependencies import Input, Output

# # Utilizando a base de dados df_final_limpo, df_tudao, df_contratog e df_contratoh já carregadas
# df = df_final_limpo
# df_tudao = df_tudao2
# df_contratog = df_contratog
# df_contratoh = df_contratoh

# # Converter as colunas de data para o tipo datetime
# df['created_at'] = pd.to_datetime(df['created_at'], errors='coerce')
# df_tudao['Data Inscrição'] = pd.to_datetime(df_tudao['Data Inscrição'], errors='coerce')

# # Calcular a média de pessoas por dia
# total_pessoas = df_tudao['numero_wpp'].nunique()
# total_dias = df_tudao['Data Inscrição'].nunique()
# media_pessoas_dia = total_pessoas / total_dias if total_dias > 0 else 0

# # Calcular total de contratos assinados
# total_contratos_assinados = df_tudao[df_tudao['CONTRATO ASSINADO'] == 1].shape[0]

# # Inicializar o aplicativo Dash
# app = dash.Dash(__name__, external_stylesheets=[dbc.themes.BOOTSTRAP], suppress_callback_exceptions=True)

# # Estilos personalizados para os cards
# CARD_STYLE = {
#     "padding": "20px",
#     "border-radius": "5px",
#     "box-shadow": "2px 2px 10px rgba(0, 0, 0, 0.1)",
#     "text-align": "center",
#     "margin-left": "20px",
#     "background-color": "#007bff",  # Fundo azul para o card da média
#     "color": "white",  # Texto branco
#     "font-size": "24px",  # Texto maior
# }

# # Estilo personalizado para o card vermelho (Total de pessoas)
# CARD_STYLE_RED = {
#     "padding": "20px",
#     "border-radius": "5px",
#     "box-shadow": "2px 2px 10px rgba(0, 0, 0, 0.1)",
#     "text-align": "center",
#     "margin-left": "20px",
#     "background-color": "#ff4d4d",  # Fundo vermelho
#     "color": "white",  # Texto branco
#     "font-size": "24px",  # Texto maior
# }

# # Estilo personalizado para o card verde (Total de contratos)
# CARD_STYLE_GREEN = {
#     "padding": "20px",
#     "border-radius": "5px",
#     "box-shadow": "2px 2px 10px rgba(0, 0, 0, 0.1)",
#     "text-align": "center",
#     "margin-left": "20px",
#     "background-color": "#28a745",  # Fundo verde
#     "color": "white",  # Texto branco
#     "font-size": "24px",  # Texto maior
# }

# # Estilos personalizados
# SIDEBAR_STYLE = {
#     "position": "fixed",
#     "top": 0,
#     "left": 0,
#     "bottom": 0,
#     "width": "20%",
#     "padding": "20px",
#     "background-color": "#343a40",  # Cor da barra lateral (cinza escuro)
# }

# CONTENT_STYLE = {
#     "margin-left": "20%",
#     "padding": "20px",
#     "background-color": "#f8f9fa",  # Cor da parte central/direita (cinza claro)
#     "text-align": "center"  # Centralizar o texto
# }

# # Layout da barra lateral
# sidebar = html.Div(
#     [
#         html.H2("Dashboard", className="display-6", style={"color": "white"}),
#         html.Hr(),
#         html.P("Solucionaí", className="lead", style={"color": "white"}),
#         dbc.Nav(
#             [
#                 dbc.NavLink("Home", href="/home", id="home-button", style={"color": "white"}),
#                 dbc.NavLink("Leads", href="/leads", id="leads-button", style={"color": "white"}),
#                 dbc.NavLink("Atendentes", href="/atendentes", id="atendentes-button", style={"color": "white"}),
#             ],
#             vertical=True,
#             pills=True,
#         ),
#     ],
#     style=SIDEBAR_STYLE,
# )

# # Layout da parte central/direita
# content = html.Div(
#     [
#         html.H2("Dashboard de Dados Solucionaí", className="display-4"),
#         html.Hr(),
#         html.Div(id="page-content"),
#     ],
#     style=CONTENT_STYLE,
# )

# # Layout principal combinando a barra lateral e o conteúdo
# app.layout = html.Div([sidebar, content])

# # Callback para atualizar o conteúdo da página
# @app.callback(
#     Output("page-content", "children"),
#     [Input("home-button", "n_clicks"),
#      Input("leads-button", "n_clicks"),
#      Input("atendentes-button", "n_clicks")]
# )
# def display_page(n_home, n_leads, n_atendentes):
#     ctx = dash.callback_context  # Verificar qual botão foi clicado
#     filtered_df_tudao = df_tudao  # Filtrar df_tudao
#     filtered_df = df  # Filtrar df_final_limpo para os outros gráficos

#     if not ctx.triggered:
#         return html.H3("Home, seja bem-vindo ao Dashboard de Dados da Solucionaí!")
#     else:
#         button_id = ctx.triggered[0]['prop_id'].split('.')[0]
#         if button_id == "home-button":
#             return html.H3("Home, seja bem-vindo ao Dashboard de Dados da Solucionaí!")
#         elif button_id == "leads-button":
#             try:
#                 # Gráfico 1: Total de Leads Cadastrados na Base por Período de Tempo
#                 leads_by_date = df_tudao[df_tudao['Data Inscrição'] >= '2024-08-30'].groupby(df_tudao['Data Inscrição'].dt.date).size()
#                 fig_total_leads = px.line(x=leads_by_date.index, y=leads_by_date.values, title="Total de Leads por Período",
#                                           labels={'x': 'Data', 'y': 'Número de Leads'})

#                 # Adicionar números no gráfico para cada ponto
#                 fig_total_leads.add_scatter(x=leads_by_date.index, y=leads_by_date.values, mode='text',
#                                             text=leads_by_date.values, textposition="top center", showlegend=False)

#                 # Ajustando o range do eixo x para que não haja espaços no início e no final
#                 fig_total_leads.update_layout(
#                     xaxis=dict(range=[leads_by_date.index.min(), leads_by_date.index.max()])
#                 )

#                 # Card com a média de pessoas por dia (card azul)
#                 card_blue = html.Div([
#                     html.H4("Média de Leads por Dia", style={"margin-bottom": "10px"}),
#                     html.Div(f"{media_pessoas_dia:.2f}", style={"font-size": "36px", "font-weight": "bold"}),
#                 ], style=CARD_STYLE)

#                 # Card com o total de pessoas (card vermelho)
#                 card_red = html.Div([
#                     html.H4("Total de Leads na Base", style={"margin-bottom": "10px"}),
#                     html.Div(f"{total_pessoas}", style={"font-size": "36px", "font-weight": "bold"}),
#                 ], style=CARD_STYLE_RED)

#                 # Card com o total de contratos assinados (card verde)
#                 card_green = html.Div([
#                     html.H4("Total Contratos Assinados", style={"margin-bottom": "10px"}),
#                     html.Div(f"{total_contratos_assinados}", style={"font-size": "36px", "font-weight": "bold"}),
#                 ], style=CARD_STYLE_GREEN)

#                 # Gráfico: Contratos Fechados por Período
#                 contratos_by_date = df_tudao[df_tudao['CONTRATO ASSINADO'] == 1].groupby(df_tudao['Data Inscrição'].dt.date).size()
#                 fig_contratos_tempo = px.line(x=contratos_by_date.index, y=contratos_by_date.values, title="Contratos Fechados por Período",
#                                               labels={'x': 'Data', 'y': 'Número de Contratos Fechados'})

#                 # Exibir informações de leads captados e proporção por problema selecionado
#                 leads_captados_total = len(df_tudao['numero_wpp'].unique())

#                 # 2. Leads Cadastrados na Base por Tipo de Problema
#                 leads_by_problem = df['PROBLEMA'].value_counts()
#                 fig_leads_problema = px.bar(x=leads_by_problem.index, y=leads_by_problem.values, title="Leads por Tipo de Problema",
#                                             labels={'x': 'Tipo de Problema', 'y': 'Contagem de Leads'})

#                 # 3. Leads Cadastrados por Região ou DDD
#                 leads_by_ddd = df_tudao['Estado'].value_counts()
#                 leads_by_ddd = leads_by_ddd[leads_by_ddd > 9]  # Filtrar para exibir apenas os valores maiores que 9
#                 fig_leads_ddd = px.bar(x=leads_by_ddd.index, y=leads_by_ddd.values, title="Leads por Região",
#                                        labels={'x': 'Estado', 'y': 'Contagem de Leads'})

#                 # 4. Leads que Responderam o Fluxo até o Final
#                 completed_flow = df_tudao[df_tudao['COMPLETOU_O_FLUXO'] == 1].shape[0]
#                 fig_fluxo_completo = px.pie(values=[completed_flow, df_tudao.shape[0] - completed_flow],
#                                             names=['Completaram', 'Não Completaram'],
#                                             title="Leads que Completaram o Fluxo até o Final")

#                 # Gráfico: Leads que Não Prosseguiram após o Primeiro Contato
#                 leads_nao_prosseguiram = filtered_df[(filtered_df['ClienteDesistiu'] == 1) | (filtered_df['SEM RESPOSTA'] == 1)].shape[0]
#                 fig_leads_nao_prosseguiram = px.pie(values=[leads_nao_prosseguiram, filtered_df.shape[0] - leads_nao_prosseguiram],
#                                                     names=['Não Prosseguiram', 'Prosseguiram'],
#                                                     title="Leads que Não Prosseguiram após o Primeiro Contato")

#                 # Gráfico: Motivo de Perda dos Leads Não Elegíveis
#                 motivo_perda = filtered_df[filtered_df['NÃO ELEGÍVEL'] == 1]['lost_reason'].value_counts()
#                 fig_motivos_perda_leads = px.bar(x=motivo_perda.index, y=motivo_perda.values, title="Motivo de Perda dos Leads Não Elegíveis",
#                                                  labels={'x': 'Motivo', 'y': 'Número de Leads Não Elegíveis'})

#                 # Exibir os gráficos juntos com o card ao lado do gráfico de contratos
#                 contratos_section = html.Div(
#                     [
#                         dcc.Graph(figure=fig_contratos_tempo),
#                         card_green  # Colocando o card verde ao lado do gráfico de contratos
#                     ],
#                     style={'display': 'flex', 'align-items': 'center', 'gap': '20px'}
#                 )

#                 return html.Div([
#                     html.Div([dcc.Graph(figure=fig_total_leads),
#                               html.Div([card_red, card_blue], style={"display": "flex", "flex-direction": "column", "align-items": "center", "gap": "20px"})],
#                              style={'display': 'flex', 'align-items': 'flex-start'}),
#                     # Contratos fechados por período com card verde ao lado
#                     contratos_section,
#                     dcc.Graph(figure=fig_leads_problema),
#                     dcc.Graph(figure=fig_leads_ddd),
#                     dcc.Graph(figure=fig_fluxo_completo),
#                     dcc.Graph(figure=fig_leads_nao_prosseguiram),
#                     dcc.Graph(figure=fig_motivos_perda_leads)
#                 ])
#             except Exception as e:
#                 return html.Div(f"Erro ao carregar os dados: {str(e)}")

#         elif button_id == "atendentes-button":
#             # Gráficos de atendimentos e interações por atendente
#             df_gabi['owner_name'] = 'Gabrielle'
#             df_hermes['owner_name'] = 'Hermes Moriguchi'
#             df_combined = pd.concat([df_gabi, df_hermes], ignore_index=True)
#             df_combined['Data Inscrição'] = pd.to_datetime(df_combined['Data Inscrição'], errors='coerce')
#             df_28 = df_combined[df_combined['Data Inscrição'] >= '2024-08-30']
#             atendimentos_por_dia = df_28.groupby([df_28['Data Inscrição'].dt.date, 'owner_name']).size().reset_index(name='Atendimentos')
#             fig_atendimentos_por_dia = px.line(atendimentos_por_dia, x='Data Inscrição', y='Atendimentos', color='owner_name',
#                                                title="Atendimentos por Dia por Atendente",
#                                                labels={'Data Inscrição': 'Data', 'Atendimentos': 'Número de Atendimentos'})

#             # Gráfico de interações por lead por atendente
#             df_filtered_atendentes = filtered_df[filtered_df['owner_name'] != 'Solucionaí']
#             interacoes_por_lead = df_filtered_atendentes.groupby('owner_name').size()
#             fig_interacoes_por_lead = px.bar(x=interacoes_por_lead.index, y=interacoes_por_lead.values, title="Total de Interações com Leads por Atendente",
#                                              labels={'x': 'Atendente', 'y': 'Número de Leads'})

#             # Gráfico de contratos fechados por Gabrielle e Hermes
#             total_contratos_gabi = df_contratog['Telefone'].count()
#             total_contratos_hermes = df_contratoh['Telefone'].count()
#             fig_contratos_por_atendente = px.bar(x=['Gabrielle', 'Hermes Moriguchi'],
#                                                  y=[total_contratos_gabi, total_contratos_hermes],
#                                                  title="Contratos Fechados por Atendente",
#                                                  labels={'x': 'Atendente', 'y': 'Número de Contratos Fechados'})

#             return html.Div([
#                 dcc.Graph(figure=fig_atendimentos_por_dia),
#                 dcc.Graph(figure=fig_interacoes_por_lead),
#                 dcc.Graph(figure=fig_contratos_por_atendente)
#             ])


# # Rodar o aplicativo
# if __name__ == "__main__":
#     app.run_server(debug=True)

# import dash
# from dash import dcc, html
# import dash_bootstrap_components as dbc
# import plotly.express as px
# import pandas as pd
# from dash.dependencies import Input, Output

# # Utilizando a base de dados df_final_limpo, df_tudao, df_contratog e df_contratoh já carregadas
# df = df_final_limpo
# df_tudao = df_tudao2
# df_contratog = df_contratog
# df_contratoh = df_contratoh

# # Converter as colunas de data para o tipo datetime
# df['created_at'] = pd.to_datetime(df['created_at'], errors='coerce')
# df_tudao['Data Inscrição'] = pd.to_datetime(df_tudao['Data Inscrição'], errors='coerce')

# # Calcular a média de pessoas por dia
# total_pessoas = df_tudao['numero_wpp'].nunique()
# total_dias = df_tudao['Data Inscrição'].nunique()
# media_pessoas_dia = total_pessoas / total_dias if total_dias > 0 else 0

# # Calcular total de contratos assinados
# total_contratos_assinados = df_tudao[df_tudao['CONTRATO ASSINADO'] == 1].shape[0]

# # Inicializar o aplicativo Dash
# app = dash.Dash(__name__, external_stylesheets=[dbc.themes.BOOTSTRAP], suppress_callback_exceptions=True)

# # Estilos personalizados para os cards
# CARD_STYLE = {
#     "padding": "20px",
#     "border-radius": "5px",
#     "box-shadow": "2px 2px 10px rgba(0, 0, 0, 0.1)",
#     "text-align": "center",
#     "margin-left": "20px",
#     "background-color": "#007bff",  # Fundo azul para o card da média
#     "color": "white",  # Texto branco
#     "font-size": "24px",  # Texto maior
# }

# # Estilo personalizado para o card vermelho (Total de pessoas)
# CARD_STYLE_RED = {
#     "padding": "20px",
#     "border-radius": "5px",
#     "box-shadow": "2px 2px 10px rgba(0, 0, 0, 0.1)",
#     "text-align": "center",
#     "margin-left": "20px",
#     "background-color": "#ff4d4d",  # Fundo vermelho
#     "color": "white",  # Texto branco
#     "font-size": "24px",  # Texto maior
# }

# # Estilo personalizado para o card verde (Total de contratos)
# CARD_STYLE_GREEN = {
#     "padding": "20px",
#     "border-radius": "5px",
#     "box-shadow": "2px 2px 10px rgba(0, 0, 0, 0.1)",
#     "text-align": "center",
#     "margin-left": "20px",
#     "background-color": "#28a745",  # Fundo verde
#     "color": "white",  # Texto branco
#     "font-size": "24px",  # Texto maior
# }

# # Estilos personalizados
# SIDEBAR_STYLE = {
#     "position": "fixed",
#     "top": 0,
#     "left": 0,
#     "bottom": 0,
#     "width": "20%",
#     "padding": "20px",
#     "background-color": "#343a40",  # Cor da barra lateral (cinza escuro)
# }

# CONTENT_STYLE = {
#     "margin-left": "20%",
#     "padding": "20px",
#     "background-color": "#f8f9fa",  # Cor da parte central/direita (cinza claro)
#     "text-align": "center"  # Centralizar o texto
# }

# # Layout da barra lateral
# sidebar = html.Div(
#     [
#         html.H2("Dashboard", className="display-6", style={"color": "white"}),
#         html.Hr(),
#         html.P("Solucionaí", className="lead", style={"color": "white"}),
#         dbc.Nav(
#             [
#                 dbc.NavLink("Home", href="/home", id="home-button", style={"color": "white"}),
#                 dbc.NavLink("Leads", href="/leads", id="leads-button", style={"color": "white"}),
#                 dbc.NavLink("Atendentes", href="/atendentes", id="atendentes-button", style={"color": "white"}),
#             ],
#             vertical=True,
#             pills=True,
#         ),
#     ],
#     style=SIDEBAR_STYLE,
# )

# # Layout da parte central/direita
# content = html.Div(
#     [
#         html.H2("Dashboard de Dados Solucionaí", className="display-4"),
#         html.Hr(),
#         html.Div(id="page-content"),
#     ],
#     style=CONTENT_STYLE,
# )

# # Layout principal combinando a barra lateral e o conteúdo
# app.layout = html.Div([sidebar, content])

# # Callback para atualizar o conteúdo da página
# @app.callback(
#     Output("page-content", "children"),
#     [Input("home-button", "n_clicks"),
#      Input("leads-button", "n_clicks"),
#      Input("atendentes-button", "n_clicks")]
# )
# def display_page(n_home, n_leads, n_atendentes):
#     ctx = dash.callback_context  # Verificar qual botão foi clicado
#     filtered_df_tudao = df_tudao  # Filtrar df_tudao
#     filtered_df = df  # Filtrar df_final_limpo para os outros gráficos

#     if not ctx.triggered:
#         return html.H3("Home, seja bem-vindo ao Dashboard de Dados da Solucionaí!")
#     else:
#         button_id = ctx.triggered[0]['prop_id'].split('.')[0]
#         if button_id == "home-button":
#             return html.H3("Home, seja bem-vindo ao Dashboard de Dados da Solucionaí!")
#         elif button_id == "leads-button":
#             try:
#                 # Dropdown para selecionar o problema
#                 dropdown_problema = dcc.Dropdown(
#                     id='problema-dropdown',
#                     options=[{'label': problema, 'value': problema} for problema in filtered_df['PROBLEMA'].unique()],
#                     value=filtered_df['PROBLEMA'].unique()[0] if not filtered_df.empty else None,
#                     clearable=False,
#                     style={'width': '50%', 'margin-bottom': '20px'}
#                 )

#                 # Gráfico 1: Total de Leads Cadastrados na Base por Período de Tempo
#                 leads_by_date = df_tudao.groupby(df_tudao['Data Inscrição'].dt.date).size()
#                 fig_total_leads = px.line(x=leads_by_date.index, y=leads_by_date.values, title="Total de Leads por Período",
#                                           labels={'x': 'Data', 'y': 'Número de Leads'})

#                 # Adicionar números no gráfico para cada ponto
#                 fig_total_leads.add_scatter(x=leads_by_date.index, y=leads_by_date.values, mode='text',
#                                             text=leads_by_date.values, textposition="top center", showlegend=False)

#                 # Ajustando o range do eixo x para que não haja espaços no início e no final
#                 fig_total_leads.update_layout(
#                     xaxis=dict(range=[leads_by_date.index.min(), leads_by_date.index.max()])
#                 )

#                 # Card com a média de pessoas por dia (card azul)
#                 card_blue = html.Div([
#                     html.H4("Média de Pessoas por Dia", style={"margin-bottom": "10px"}),
#                     html.Div(f"{media_pessoas_dia:.2f}", style={"font-size": "36px", "font-weight": "bold"}),
#                 ], style=CARD_STYLE)

#                 # Card com o total de pessoas (card vermelho)
#                 card_red = html.Div([
#                     html.H4("Total de Pessoas na Base", style={"margin-bottom": "10px"}),
#                     html.Div(f"{total_pessoas}", style={"font-size": "36px", "font-weight": "bold"}),
#                 ], style=CARD_STYLE_RED)

#                 # Card com o total de contratos assinados (card verde)
#                 card_green = html.Div([
#                     html.H4("Contratos Assinados", style={"margin-bottom": "10px"}),
#                     html.Div(f"{total_contratos_assinados}", style={"font-size": "36px", "font-weight": "bold"}),
#                 ], style=CARD_STYLE_GREEN)

#                 # Exibir informações de leads captados e proporção por problema selecionado
#                 leads_captados_total = len(df_tudao['numero_wpp'].unique())
#                 leads_captados_problema = len(filtered_df[filtered_df['PROBLEMA'] == dropdown_problema.value]['numero_wpp'].unique())
#                 proporcao_leads_problema = (leads_captados_problema / leads_captados_total * 100) if leads_captados_total > 0 else 0

#                 leads_info = html.Div([
#                     html.H4(f"Leads Captados no Problema Selecionado: {leads_captados_problema}"),
#                     html.H4(f"Proporção de Leads no Problema Selecionado: {proporcao_leads_problema:.2f}%")
#                 ], style={'text-align': 'left', 'margin': '20px 0'})

#                 # 2. Leads Cadastrados na Base por Tipo de Problema
#                 leads_by_problem = df['PROBLEMA'].value_counts()
#                 fig_leads_problema = px.bar(x=leads_by_problem.index, y=leads_by_problem.values, title="Leads por Tipo de Problema",
#                                             labels={'x': 'Tipo de Problema', 'y': 'Contagem de Leads'})

#                 # 3. Leads Cadastrados por Região ou DDD
#                 leads_by_ddd = df_tudao['Estado'].value_counts()
#                 leads_by_ddd = leads_by_ddd[leads_by_ddd > 9]  # Filtrar para exibir apenas os valores maiores que 9
#                 fig_leads_ddd = px.bar(x=leads_by_ddd.index, y=leads_by_ddd.values, title="Leads por Região",
#                                        labels={'x': 'Estado', 'y': 'Contagem de Leads'})

#                 # 4. Leads que Responderam o Fluxo até o Final
#                 completed_flow = df_tudao[df_tudao['COMPLETOU_O_FLUXO'] == 1].shape[0]
#                 fig_fluxo_completo = px.pie(values=[completed_flow, df_tudao.shape[0] - completed_flow],
#                                             names=['Completaram', 'Não Completaram'],
#                                             title="Leads que Completaram o Fluxo até o Final")

#                 # Gráfico: Contratos Fechados por Período
#                 contratos_by_date = df_tudao[df_tudao['CONTRATO ASSINADO'] == 1].groupby(df_tudao['Data Inscrição'].dt.date).size()
#                 fig_contratos_tempo = px.line(x=contratos_by_date.index, y=contratos_by_date.values, title="Contratos Fechados por Período",
#                                               labels={'x': 'Data', 'y': 'Número de Contratos Fechados'})

#                 # Gráfico: Leads que Não Prosseguiram após o Primeiro Contato
#                 leads_nao_prosseguiram = filtered_df[(filtered_df['ClienteDesistiu'] == 1) | (filtered_df['SEM RESPOSTA'] == 1)].shape[0]
#                 fig_leads_nao_prosseguiram = px.pie(values=[leads_nao_prosseguiram, filtered_df.shape[0] - leads_nao_prosseguiram],
#                                                     names=['Não Prosseguiram', 'Prosseguiram'],
#                                                     title="Leads que Não Prosseguiram após o Primeiro Contato")

#                 # Gráfico: Motivo de Perda dos Leads Não Elegíveis
#                 motivo_perda = filtered_df[filtered_df['NÃO ELEGÍVEL'] == 1]['lost_reason'].value_counts()
#                 fig_motivos_perda_leads = px.bar(x=motivo_perda.index, y=motivo_perda.values, title="Motivo de Perda dos Leads Não Elegíveis",
#                                                  labels={'x': 'Motivo', 'y': 'Número de Leads Não Elegíveis'})

#                 return html.Div([
#                     dropdown_problema,  # Dropdown para selecionar o problema
#                     html.Div([dcc.Graph(figure=fig_total_leads),
#                               html.Div([card_red, card_blue], style={"display": "flex", "flex-direction": "column", "align-items": "center", "gap": "20px"})],  # Os cards vermelho e azul agora estão empilhados
#                              style={'display': 'flex', 'align-items': 'flex-start'}),  # Gráfico 1 e Cards
#                     leads_info,  # Exibir leads captados
#                     dcc.Graph(figure=fig_leads_problema),  # Gráfico 2: Leads por Tipo de Problema
#                     dcc.Graph(figure=fig_leads_ddd),  # Gráfico 3: Leads por Região ou DDD
#                     html.Div([dcc.Graph(figure=fig_contratos_tempo),  # Gráfico 5: Contratos fechados por tempo
#                               card_green], style={"display": "flex", "justify-content": "space-between"}),  # Card verde ao lado do gráfico
#                     dcc.Graph(figure=fig_fluxo_completo),  # Gráfico 4: Leads que completaram o fluxo
#                     dcc.Graph(figure=fig_leads_nao_prosseguiram),  # Gráfico 6: Leads que Não Prosseguiram
#                     dcc.Graph(figure=fig_motivos_perda_leads)  # Gráfico 7: Motivo de Perda dos Leads Não Elegíveis
#                 ])
#             except Exception as e:
#                 return html.Div(f"Erro ao carregar os dados: {str(e)}")

#         elif button_id == "atendentes-button":
#             # Supondo que os DataFrames df_gabi, df_hermes, df_contratog, e df_contratoh já estejam carregados

#             # Gráfico 9: Atendimentos por Dia por Atendente
#             df_gabi['owner_name'] = 'Gabrielle'
#             df_hermes['owner_name'] = 'Hermes Moriguchi'
#             df_combined = pd.concat([df_gabi, df_hermes], ignore_index=True)
#             df_combined['Data Inscrição'] = pd.to_datetime(df_combined['Data Inscrição'], errors='coerce')
#             df_28 = df_combined[df_combined['Data Inscrição'] >= '2024-08-28']
#             atendimentos_por_dia = df_28.groupby([df_28['Data Inscrição'].dt.date, 'owner_name']).size().reset_index(name='Atendimentos')
#             fig_atendimentos_por_dia = px.line(atendimentos_por_dia, x='Data Inscrição', y='Atendimentos', color='owner_name',
#                                                title="Atendimentos por Dia por Atendente",
#                                                labels={'Data Inscrição': 'Data', 'Atendimentos': 'Número de Atendimentos'})

#             # Gráfico 11: Interações por Lead por Atendente
#             df_filtered_atendentes = filtered_df[filtered_df['owner_name'] != 'Solucionaí']
#             interacoes_por_lead = df_filtered_atendentes.groupby('owner_name').size()
#             fig_interacoes_por_lead = px.bar(x=interacoes_por_lead.index, y=interacoes_por_lead.values, title="Total de Interações com Leads por Atendente",
#                                              labels={'x': 'Atendente', 'y': 'Número de Leads'})

#             # Gráfico 12: Contratos Fechados por Gabrielle e Hermes (Total de valores na coluna "Telefone" de df_contratog e df_contratoh)
#             total_contratos_gabi = df_contratog['Telefone'].count()
#             total_contratos_hermes = df_contratoh['Telefone'].count()
#             fig_contratos_por_atendente = px.bar(x=['Gabrielle', 'Hermes Moriguchi'],
#                                                  y=[total_contratos_gabi, total_contratos_hermes],
#                                                  title="Contratos Fechados por Atendente",
#                                                  labels={'x': 'Atendente', 'y': 'Número de Contratos Fechados'})

#             return html.Div([
#                 dcc.Graph(figure=fig_atendimentos_por_dia),  # Gráfico 9: Atendimentos por Dia por Atendente
#                 dcc.Graph(figure=fig_interacoes_por_lead),  # Gráfico 11: Interações por Lead por Atendente
#                 dcc.Graph(figure=fig_contratos_por_atendente)  # Gráfico 12: Contratos Fechados por Gabrielle e Hermes
#             ])


# # Rodar o aplicativo
# if __name__ == "__main__":
#      app.run_server(debug=True)

import dash
from dash import dcc, html
import dash_bootstrap_components as dbc
import plotly.express as px
import pandas as pd
from dash.dependencies import Input, Output

# Utilizando a base de dados df_final_limpo, df_tudao, df_contratog e df_contratoh já carregadas
df = df_final_limpo
df_tudao = df_tudao2
df_contratog = df_contratog
df_contratoh = df_contratoh

# Converter as colunas de data para o tipo datetime
df['created_at'] = pd.to_datetime(df['created_at'], errors='coerce')
df_tudao['Data Inscrição'] = pd.to_datetime(df_tudao['Data Inscrição'], errors='coerce')

# Calcular a média de pessoas por dia
total_pessoas = df_tudao['numero_wpp'].nunique()
total_dias = df_tudao['Data Inscrição'].nunique()
media_pessoas_dia = total_pessoas / total_dias if total_dias > 0 else 0

# Calcular total de contratos assinados
total_contratos_assinados = df_tudao[df_tudao['CONTRATO ASSINADO'] == 1].shape[0]

# Inicializar o aplicativo Dash
app = dash.Dash(__name__, external_stylesheets=[dbc.themes.BOOTSTRAP], suppress_callback_exceptions=True)

# Estilos personalizados para os cards
CARD_STYLE = {
    "padding": "20px",
    "border-radius": "5px",
    "box-shadow": "2px 2px 10px rgba(0, 0, 0, 0.1)",
    "text-align": "center",
    "margin-left": "20px",
    "background-color": "#007bff",  # Fundo azul para o card da média
    "color": "white",  # Texto branco
    "font-size": "24px",  # Texto maior
}

# Estilo personalizado para o card vermelho (Total de pessoas) com margem superior de 1 cm
CARD_STYLE_RED = {
    "padding": "20px",
    "border-radius": "5px",
    "box-shadow": "2px 2px 10px rgba(0, 0, 0, 0.1)",
    "text-align": "center",
    "margin-left": "20px",
    "margin-top": "1cm",  # Mover 1 cm para baixo
    "background-color": "#ff4d4d",  # Fundo vermelho
    "color": "white",  # Texto branco
    "font-size": "24px",  # Texto maior
}

# Estilo personalizado para o card azul (Média de pessoas por dia) com margem superior de 1 cm
CARD_STYLE_BLUE = {
    "padding": "20px",
    "border-radius": "5px",
    "box-shadow": "2px 2px 10px rgba(0, 0, 0, 0.1)",
    "text-align": "center",
    "margin-left": "20px",
    "margin-top": "1cm",  # Mover 1 cm para baixo
    "background-color": "#007bff",  # Fundo azul
    "color": "white",  # Texto branco
    "font-size": "24px",  # Texto maior
}

# Estilo personalizado para o card verde (Total de contratos)
CARD_STYLE_GREEN = {
    "padding": "20px",
    "border-radius": "5px",
    "box-shadow": "2px 2px 10px rgba(0, 0, 0, 0.1)",
    "text-align": "center",
    "margin-left": "20px",
    "background-color": "#28a745",  # Fundo verde
    "color": "white",  # Texto branco
    "font-size": "24px",  # Texto maior
}

# Estilos personalizados
SIDEBAR_STYLE = {
    "position": "fixed",
    "top": 0,
    "left": 0,
    "bottom": 0,
    "width": "20%",
    "padding": "20px",
    "background-color": "#343a40",  # Cor da barra lateral (cinza escuro)
}

CONTENT_STYLE = {
    "margin-left": "20%",
    "padding": "20px",
    "background-color": "#f8f9fa",  # Cor da parte central/direita (cinza claro)
    "text-align": "center"  # Centralizar o texto
}

# Layout da barra lateral
sidebar = html.Div(
    [
        html.H2("Dashboard", className="display-6", style={"color": "white"}),
        html.Hr(),
        html.P("Solucionaí", className="lead", style={"color": "white"}),
        dbc.Nav(
            [
                dbc.NavLink("Home", href="/home", id="home-button", style={"color": "white"}),
                dbc.NavLink("Leads", href="/leads", id="leads-button", style={"color": "white"}),
                dbc.NavLink("Atendentes", href="/atendentes", id="atendentes-button", style={"color": "white"}),
            ],
            vertical=True,
            pills=True,
        ),
    ],
    style=SIDEBAR_STYLE,
)

# Layout da parte central/direita
content = html.Div(
    [
        html.H2("Dashboard de Dados Solucionaí", className="display-4"),
        html.Hr(),
        html.Div(id="page-content"),
    ],
    style=CONTENT_STYLE,
)

# Layout principal combinando a barra lateral e o conteúdo
app.layout = html.Div([sidebar, content])

# Callback para atualizar o conteúdo da página
@app.callback(
    Output("page-content", "children"),
    [Input("home-button", "n_clicks"),
     Input("leads-button", "n_clicks"),
     Input("atendentes-button", "n_clicks")]
)
def display_page(n_home, n_leads, n_atendentes):
    ctx = dash.callback_context  # Verificar qual botão foi clicado
    filtered_df_tudao = df_tudao  # Filtrar df_tudao
    filtered_df = df  # Filtrar df_final_limpo para os outros gráficos

    if not ctx.triggered:
        return html.H3("Home, seja bem-vindo ao Dashboard de Dados da Solucionaí!")
    else:
        button_id = ctx.triggered[0]['prop_id'].split('.')[0]
        if button_id == "home-button":
            return html.H3("Home, seja bem-vindo ao Dashboard de Dados da Solucionaí!")
        elif button_id == "leads-button":
            try:
                # Gráfico 1: Total de Leads Cadastrados na Base por Período de Tempo
                leads_by_date = df_tudao[df_tudao['Data Inscrição'] >= '2024-08-30'].groupby(df_tudao['Data Inscrição'].dt.date).size()
                fig_total_leads = px.line(x=leads_by_date.index, y=leads_by_date.values, title="Total de Leads por Período",
                                          labels={'x': 'Data', 'y': 'Número de Leads'})

                # Adicionar números no gráfico para cada ponto
                fig_total_leads.add_scatter(x=leads_by_date.index, y=leads_by_date.values, mode='text',
                                            text=leads_by_date.values, textposition="top center", showlegend=False)

                # Ajustando o range do eixo x para que não haja espaços no início e no final
                fig_total_leads.update_layout(
                    xaxis=dict(range=[leads_by_date.index.min(), leads_by_date.index.max()])
                )

                # Card com a média de pessoas por dia (card azul)
                card_blue = html.Div([
                    html.H4("Média de Leads por Dia", style={"margin-bottom": "10px"}),
                    html.Div(f"{media_pessoas_dia:.2f}", style={"font-size": "36px", "font-weight": "bold"}),
                ], style=CARD_STYLE_BLUE)

                # Card com o total de pessoas (card vermelho)
                card_red = html.Div([
                    html.H4("Total de Leads na Base", style={"margin-bottom": "10px"}),
                    html.Div(f"{total_pessoas}", style={"font-size": "36px", "font-weight": "bold"}),
                ], style=CARD_STYLE_RED)

                # Card com o total de contratos assinados (card verde)
                card_green = html.Div([
                    html.H4("Contratos Assinados", style={"margin-bottom": "10px"}),
                    html.Div(f"{total_contratos_assinados}", style={"font-size": "36px", "font-weight": "bold"}),
                ], style=CARD_STYLE_GREEN)

                # Gráfico: Contratos Fechados por Período
                contratos_by_date = df_tudao[df_tudao['CONTRATO ASSINADO'] == 1].groupby(df_tudao['Data Inscrição'].dt.date).size()
                fig_contratos_tempo = px.line(x=contratos_by_date.index, y=contratos_by_date.values, title="Contratos Fechados por Período",
                                              labels={'x': 'Data', 'y': 'Número de Contratos Fechados'})

                # Exibir informações de leads captados e proporção por problema selecionado
                leads_captados_total = len(df_tudao['numero_wpp'].unique())

                # 2. Leads Cadastrados na Base por Tipo de Problema
                leads_by_problem = df['PROBLEMA'].value_counts()
                fig_leads_problema = px.bar(x=leads_by_problem.index, y=leads_by_problem.values, title="Leads por Tipo de Problema",
                                            labels={'x': 'Tipo de Problema', 'y': 'Contagem de Leads'})

                # 3. Leads Cadastrados por Região ou DDD
                leads_by_ddd = df_tudao['Estado'].value_counts()
                leads_by_ddd = leads_by_ddd[leads_by_ddd > 9]  # Filtrar para exibir apenas os valores maiores que 9
                fig_leads_ddd = px.bar(x=leads_by_ddd.index, y=leads_by_ddd.values, title="Leads por Região",
                                       labels={'x': 'Estado', 'y': 'Contagem de Leads'})

                # 4. Leads que Responderam o Fluxo até o Final
                completed_flow = df_tudao[df_tudao['COMPLETOU_O_FLUXO'] == 1].shape[0]
                fig_fluxo_completo = px.pie(values=[completed_flow, df_tudao.shape[0] - completed_flow],
                                            names=['Completaram', 'Não Completaram'],
                                            title="Leads que Completaram o Fluxo até o Final")

                # Gráfico: Leads que Não Prosseguiram após o Primeiro Contato
                leads_nao_prosseguiram = filtered_df[(filtered_df['ClienteDesistiu'] == 1) | (filtered_df['SEM RESPOSTA'] == 1)].shape[0]
                fig_leads_nao_prosseguiram = px.pie(values=[leads_nao_prosseguiram, filtered_df.shape[0] - leads_nao_prosseguiram],
                                                    names=['Não Prosseguiram', 'Prosseguiram'],
                                                    title="Leads que Não Prosseguiram após o Primeiro Contato")

                # Gráfico: Motivo de Perda dos Leads Não Elegíveis
                motivo_perda = filtered_df[filtered_df['NÃO ELEGÍVEL'] == 1]['lost_reason'].value_counts()
                fig_motivos_perda_leads = px.bar(x=motivo_perda.index, y=motivo_perda.values, title="Motivo de Perda dos Leads Não Elegíveis",
                                                 labels={'x': 'Motivo', 'y': 'Número de Leads Não Elegíveis'})

                # Exibir os gráficos juntos com o card ao lado do gráfico de contratos
                contratos_section = html.Div(
                    [
                        dcc.Graph(figure=fig_contratos_tempo),
                        card_green  # Colocando o card verde ao lado do gráfico de contratos
                    ],
                    style={'display': 'flex', 'align-items': 'center', 'gap': '20px'}
                )

                return html.Div([
                    html.Div([dcc.Graph(figure=fig_total_leads),
                              html.Div([card_red, card_blue], style={"display": "flex", "flex-direction": "column", "align-items": "center", "gap": "20px"})],
                             style={'display': 'flex', 'align-items': 'flex-start'}),
                    # Contratos fechados por período com card verde ao lado
                    contratos_section,
                    dcc.Graph(figure=fig_leads_problema),
                    dcc.Graph(figure=fig_leads_ddd),
                    dcc.Graph(figure=fig_fluxo_completo),
                    dcc.Graph(figure=fig_leads_nao_prosseguiram),
                    dcc.Graph(figure=fig_motivos_perda_leads)
                ])
            except Exception as e:
                return html.Div(f"Erro ao carregar os dados: {str(e)}")

        elif button_id == "atendentes-button":
            # Gráficos de atendimentos e interações por atendente
            df_gabi['owner_name'] = 'Gabrielle'
            df_hermes['owner_name'] = 'Hermes Moriguchi'
            df_combined = pd.concat([df_gabi, df_hermes], ignore_index=True)
            df_combined['Data Inscrição'] = pd.to_datetime(df_combined['Data Inscrição'], errors='coerce')
            df_28 = df_combined[df_combined['Data Inscrição'] >= '2024-08-30']
            atendimentos_por_dia = df_28.groupby([df_28['Data Inscrição'].dt.date, 'owner_name']).size().reset_index(name='Atendimentos')
            fig_atendimentos_por_dia = px.line(atendimentos_por_dia, x='Data Inscrição', y='Atendimentos', color='owner_name',
                                               title="Atendimentos por Dia por Atendente",
                                               labels={'Data Inscrição': 'Data', 'Atendimentos': 'Número de Atendimentos'})

            # Gráfico de interações por lead por atendente
            df_filtered_atendentes = filtered_df[filtered_df['owner_name'] != 'Solucionaí']
            interacoes_por_lead = df_filtered_atendentes.groupby('owner_name').size()
            fig_interacoes_por_lead = px.bar(x=interacoes_por_lead.index, y=interacoes_por_lead.values, title="Total de Interações com Leads por Atendente",
                                             labels={'x': 'Atendente', 'y': 'Número de Leads'})

            # Gráfico de contratos fechados por Gabrielle e Hermes
            total_contratos_gabi = df_contratog['Telefone'].count()
            total_contratos_hermes = df_contratoh['Telefone'].count()
            fig_contratos_por_atendente = px.bar(x=['Gabrielle', 'Hermes Moriguchi'],
                                                 y=[total_contratos_gabi, total_contratos_hermes],
                                                 title="Contratos Fechados por Atendente",
                                                 labels={'x': 'Atendente', 'y': 'Número de Contratos Fechados'})

            return html.Div([
                dcc.Graph(figure=fig_atendimentos_por_dia),
                dcc.Graph(figure=fig_interacoes_por_lead),
                dcc.Graph(figure=fig_contratos_por_atendente)
            ])


if __name__ == "__main__":
    app.run_server(debug=True, host='0.0.0.0', port=8080)
